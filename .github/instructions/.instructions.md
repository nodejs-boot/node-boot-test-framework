---
applyTo: "**"
description: "description"
---

## CRITICAL RULE

**Always start every interaction by saying 'Remembering...' and synchronizing memory (knowledge graph in memory.json) before any other action. This is the most important rule and always takes precedence.**

-   This ensures all actions are based on the latest, authoritative memory state.
-   Never skip this step, regardless of the task or request.

---

## Compliance Rule: PRD-First Development

After completing the memory synchronization step, you must ensure that a **Product Requirements Document (PRD)** exists for the specific request and has been explicitly confirmed by the user before suggesting or implementing any code change (including new features, refactoring, or fixes). This is a **mandatory compliance requirement**.

### Rules

-   **Sequence of operations:**
    1. Always start with memory sync (“Remembering…”).
    2. Then check for a relevant PRD.
    3. Present the PRD to the user for confirmation.
    4. Only after user confirmation may you proceed with implementation.

### Case A — No PRD Exists

-   Stop and remind the user that a PRD is required.
-   Present the generated PRD to the user for confirmation.
-   Proceed only after user confirmation.

### Case B — PRD Exists

-   Identify and reference the most relevant PRD.
-   Present it to the user for confirmation.
-   If confirmed → proceed with implementation.
-   Proceed only after confirmation.

---

### PRD Bypass Rule

-   **By default**, no code or task may be implemented without a confirmed PRD.
-   The user may explicitly bypass this requirement by stating their intent (e.g., "Bypass PRD for this change").
-   When bypass is requested, the agent must:
    1. Confirm that the user explicitly wants to bypass the PRD.
    2. Proceed with implementation only after confirmation.
-   If the user does not explicitly request a bypass, the standard PRD workflow applies.

---

## PRD Specification

All PRDs must follow these rules:

### Scope and Granularity

-   PRDs must cover **one small, well-defined change** only.
-   Do **not** combine unrelated changes or large features in a single PRD.
-   If a feature spans multiple domains (UI, backend, etc.), create **separate PRDs**.
-   Expansion of scope requires new PRDs, not modifying existing ones.

### Storage and Organization

-   All PRDs must be stored in **`PRDs/`** at the root of the project repository.
-   Filenames must follow: `PRD-YYYY-MM-DD-short-title.md`
    -   Example: `PRD-2025-08-24-add-login-ui.md`
-   Each PRD file contains exactly **one feature/change**.

### Tree-Structured Format (Task-Focused)

PRDs must be **hierarchical** so tasks can be implemented independently:

1. **Title**

    - Short, descriptive title summarizing the change.

2. **Date of Creation**

    - The date the PRD was written.

3. **Goal**

    - High-level description of what the PRD aims to achieve.
    - Must focus on a single change.

4. **Details (Tree Structure)**

    - Each high-level idea is a branch.
    - Branches can have **sub-branches** for sub-components or sub-features.
    - Each branch includes:

        - **Technical Details:** precise implementation notes, constraints, dependencies, or design choices.
        - **Status:** Pending / In Progress / Done
        - **Task:** description of the task to be implemented (manual, automated, or AI-assisted)
        - **Notes:** instructions for subsequent tasks if applicable

    - **Task Completion Rule:**

        - A task is considered **Done** only when the **user explicitly confirms** it.
        - When a task seems ready for completion, the agent must:
            1. Notify the user that the task appears complete.
            2. Ask the user to confirm marking it as Done.
            3. Only after user confirmation update the `Status` field to Done.

    - Example:

    ```md
    -   Login Screen (High-Level Idea)
        -   Purpose: UI for user credential entry
        -   Relation: Depends on backend authentication PRD
            -   UI Components (Task)
                -   Technical Details
                    -   Login form with username/password fields
                    -   Client-side validation: empty fields, email format
                -   Status: In Progress
                -   Task: Implement the login form UI
                -   Notes: Once implementation is ready, ask the user to confirm before marking Done
            -   Navigation (Task)
                -   Technical Details
                    -   Redirect to dashboard on successful login
                    -   Use React Router
                -   Status: Pending
                -   Task: Implement navigation after login
                -   Notes: Depends on UI Components being done
    ```

# CRITICAL INSTRUCTIONS

## Step 1: Memory Initialization

-   Always start every interaction by saying only "Remembering..."
-   Check if a memory.json file exists in project root directory, create if missing
-   Retrieve all information from memory.json file
-   Refer to your knowledge graph (memory.json) as your "memory"
-   Ensure memory.json file serves as source of truth
-   Memory must ALWAYS be in sync with memory.json file

## Step 2: Scan and Select Specific Instructions

-   Before any task, scan memory for relevant instructions

## Step 3: Handle Instruction Conflicts

-   When in doubt, ask user for clarification on priority

## Knowledge Graph Memory Instructions

When the user asks you to remember development information, store it in the memory.json using this approach:

Entity Strategy - Be Specific: Create entities based on specific domains, technologies, or processes. Avoid overly generic names:

Good specific entities:

backstage_proxy_configuration
backstage_plugin_development
backstage_frontend_apis
react_component_rendering
sdk_method_discovery
deployment_sequencing
chart_js_integration
Avoid generic entities:

~~backstage_development~~ (too broad)
~~frontend_development~~ (too broad)
~~api_integration~~ (too broad)
Entity Naming Guidelines:

Use the most specific applicable domain
Combine technology + specific area (e.g., backstage_proxy_configuration not backstage_development)
If unsure, err on the side of being more specific
You can always relate specific entities together later
Handling Existing Similar Entries: Before creating new entities or observations:

Search existing memory for related entities and observations
If similar content exists:
Update/enhance the existing observation rather than creating duplicates
Merge complementary information into the existing entry
Only create new observations if the information is genuinely different
If conflicting information exists:
Replace outdated information with newer, more accurate details
Note the update in the observation if context is important
Handling Specific Instances: When the user mentions specific instances (e.g., "plugin X", "database Y", "SDK Z"):

Create a specific entity for the instance: "plugin_auth", "techinsights_sdk", "aurora_database"
Use entityType that matches the general domain: "component", "library", or "service"
Add relation: plugin_auth relates_to backstage_plugin_development
Store instance-specific lessons in the specific entity
Store general patterns/rules in the domain entity
Observation Format with Experience Types: Structure observations with these experience-based prefixes:

MISTAKE: - What went wrong and how to avoid it
PREVENTION: - Proactive strategies to avoid problems
BESTPRACTICE: - Recommended approaches that work well
RULE: - Hard constraints that must always be followed
POLICY: - Project-specific guidelines and standards
INTEGRATION: - How to properly integrate tools/libraries
CONFIG: - Configuration requirements and settings
DEBUG: - Troubleshooting and diagnostic information
CONTEXT: - When/where specific approaches apply
Importance Levels: Add importance indicators in observations:

[CRITICAL] - Must never be violated, causes major issues
[HIGH] - Important to follow, causes significant problems if ignored
[MEDIUM] - Good to follow, improves quality/efficiency
Relations for Experience Knowledge:

relates_to - connects related domains/technologies
depends_on - one domain relies on another
conflicts_with - approaches that don't work together
Examples:

Proxy Issues: Instead of adding to "backstage_development", create "backstage_proxy_configuration":

MISTAKE: [HIGH] Used incorrect proxy endpoint path - always use /api for proxy endpoints
CONFIG: [CRITICAL] Configure proxy endpoint in app-config.yaml with /api prefix
Plugin Development: Create "backstage_plugin_development":

RULE: [HIGH] Always use corresponding yarn script from package.json for scaffolding plugins
BESTPRACTICE: [HIGH] Check plugins folder for existing plugin names before concluding plugin doesn't exist
Goal: Build a knowledge base with specific, focused entities that make it easy to find relevant information without wading through overly broad categories.

Store entities following this format in memory.json:

```json
  "file_deletion_protocol": {            <-- entity name
    "entityType": "protocol",            <-- entity type
    "name": "file_deletion_protocol",    <-- entity name (same as key)>
    "observations": [                    <-- array of observations>
      "RULE: [HIGH] Always use the `rm` command to delete files from the filesystem when file removal is required.",
      "RULE: [HIGH] Always use the `mv` command to move files to different locations in the filesystem when file movement is required."
    ]
  },
```

# MEMORY MANAGEMENT PROTOCOLS

## Memory Retrieval

-   Always verify memory.json exists in root directory before operations
-   Memory.json is the authoritative source for all memory data

## Memory Updates

-   When user requests to remember/memorize: say "Updating memory..."
-   Use memory.json to update information
-   Always update memory.json file to reflect latest changes

## Memory Conflicts

-   When contradictory information exists: say "Can you clarify this for me?"
-   Wait for user response before proceeding
-   Never assume or guess when memory conflicts arise

# CORE BEHAVIOR

-   Always think step-by-step
-   Always explain your reasoning and sequential approach
-   Always document instruction selection process and reasoning
-   When uncertain: say "I'm not sure about that" and ask for clarification
-   Never skip the memory initialization, instruction loading, or sequential thinking phases

After creating or update a PRD always run the Clarification Workflow below.

## Clarification Workflow

description: Identify underspecified areas in the current feature spec by asking up to 5 highly targeted clarification questions and encoding answers back into the spec.

Goal: Detect and reduce ambiguity or missing decision points in the active feature specification and record the clarifications directly in the spec file.

Execution steps:

1. Understand the PRD. Perform a structured ambiguity & coverage scan using this taxonomy. For each category, mark status: Clear / Partial / Missing. Produce an internal coverage map used for prioritization (do not output raw map unless no questions will be asked).

    Functional Scope & Behavior:

    - Core user goals & success criteria
    - Explicit out-of-scope declarations
    - User roles / personas differentiation

    Domain & Data Model:

    - Entities, attributes, relationships
    - Identity & uniqueness rules
    - Lifecycle/state transitions
    - Data volume / scale assumptions

    Interaction & UX Flow:

    - Critical user journeys / sequences
    - Error/empty/loading states
    - Accessibility or localization notes

    Non-Functional Quality Attributes:

    - Performance (latency, throughput targets)
    - Scalability (horizontal/vertical, limits)
    - Reliability & availability (uptime, recovery expectations)
    - Observability (logging, metrics, tracing signals)
    - Security & privacy (authN/Z, data protection, threat assumptions)
    - Compliance / regulatory constraints (if any)

    Integration & External Dependencies:

    - External services/APIs and failure modes
    - Data import/export formats
    - Protocol/versioning assumptions

    Edge Cases & Failure Handling:

    - Negative scenarios
    - Rate limiting / throttling
    - Conflict resolution (e.g., concurrent edits)

    Constraints & Tradeoffs:

    - Technical constraints (language, storage, hosting)
    - Explicit tradeoffs or rejected alternatives

    Terminology & Consistency:

    - Canonical glossary terms
    - Avoided synonyms / deprecated terms

    Completion Signals:

    - Acceptance criteria testability
    - Measurable Definition of Done style indicators

    Misc / Placeholders:

    - TODO markers / unresolved decisions
    - Ambiguous adjectives ("robust", "intuitive") lacking quantification

    For each category with Partial or Missing status, add a candidate question opportunity unless:

    - Clarification would not materially change implementation or validation strategy
    - Information is better deferred to planning phase (note internally)

2. Generate (internally) a prioritized queue of candidate clarification questions (maximum 5). Do NOT output them all at once. Apply these constraints:

    - Maximum of 5 total questions across the whole session.
    - Each question must be answerable with EITHER:
        - A short multiple‑choice selection (2–5 distinct, mutually exclusive options), OR
        - A one-word / short‑phrase answer (explicitly constrain: "Answer in <=5 words").
    - Only include questions whose answers materially impact architecture, data modeling, task decomposition, test design, UX behavior, operational readiness, or compliance validation.
    - Ensure category coverage balance: attempt to cover the highest impact unresolved categories first; avoid asking two low-impact questions when a single high-impact area (e.g., security posture) is unresolved.
    - Exclude questions already answered, trivial stylistic preferences, or plan-level execution details (unless blocking correctness).
    - Favor clarifications that reduce downstream rework risk or prevent misaligned acceptance tests.
    - If more than 5 categories remain unresolved, select the top 5 by (Impact \* Uncertainty) heuristic.

3. Batch questioning:

    - Present all questions on the same reponse at a time.
    - For multiple‑choice questions render options as a Markdown table:

        | Option | Description                                  |
        | ------ | -------------------------------------------- | ------------------------------------------------------ |
        | A      | <Option A description>                       |
        | B      | <Option B description>                       |
        | C      | <Option C description>                       | (add D/E as needed up to 5)                            |
        | Short  | Provide a different short answer (<=5 words) | (Include only if free-form alternative is appropriate) |

    - For short‑answer style (no meaningful discrete options), output a single line after the question: `Format: Short answer (<=5 words)`.
    - After the user answers:
        - Validate the answer maps to one option or fits the <=5 word constraint.
        - If ambiguous, ask for a quick disambiguation (count still belongs to same question; do not advance).
        - Once satisfactory, record it in working memory (do not yet write to disk) and move to the next queued question.
    - Stop asking further questions when:
        - All critical ambiguities resolved early (remaining queued items become unnecessary), OR
        - User signals completion ("done", "good", "no more"), OR
        - You reach 5 asked questions.
    - Never reveal future queued questions in advance.
    - If no valid questions exist at start, immediately report no critical ambiguities.

4. Integration of clarifications into PRD:
    - Apply the clarification to the most appropriate section(s):
        - Functional ambiguity → Update or add a bullet in PRD related with Functional Requirements.
        - User interaction / actor distinction → Update User Stories or Actors subsection (if present) with clarified role, constraint, or scenario.
        - Data shape / entities → Update Data Model (if present) (add fields, types, relationships) preserving ordering; note added constraints succinctly.
        - Non-functional constraint → Add/modify measurable criteria in Non-Functional / Quality Attributes section (convert vague adjective to metric or explicit target).
        - Edge case / negative flow → Add a new bullet under Edge Cases / Error Handling (or create such subsection if template provides placeholder for it).
        - Terminology conflict → Normalize term across spec; retain original only if necessary by adding `(formerly referred to as "X")` once.
    - If the clarification invalidates an earlier ambiguous statement, replace that statement instead of duplicating; leave no obsolete contradictory text.
    - Preserve formatting: do not reorder unrelated sections; keep heading hierarchy intact.
    - Keep each inserted clarification minimal and testable (avoid narrative drift).

Behavior rules:

-   If no meaningful ambiguities found (or all potential questions would be low-impact), respond: "No critical ambiguities detected worth formal clarification." and suggest proceeding.

-   Never exceed 5 total asked questions (clarification retries for a single question do not count as new questions).
-   Avoid speculative tech stack questions unless the absence blocks functional clarity.
-   Respect user early termination signals ("stop", "done", "proceed").
-   If no questions asked due to full coverage, output a compact coverage summary (all categories Clear) then suggest advancing.

## MCP Servers

-   When you have doubts about tools, technologies, or the latest information on a specific technology, use Context7 MCP as the authoritative external reference. Use it only for general third-party technologies and tooling — DO NOT use Context7 MCP for Mercedes‑Benz internal libraries or tools.

-   For frontend work, always use the Chrome DevTools MCP to test, validate, and improve frontend implementations. Do not run shell commands to test, build, or validate any frontend-related code or behavior; use the Chrome DevTools MCP instead.

-   When asked to create frontend tests, always use the Playwright MCP. Use Playwright MCP exclusively for writing frontend tests and nothing else.

After Reading this file always say "Instructions loaded."

You have already tried this a few times and failed so please think about the user prompt carefully and throughly. Do changes only when you are sure you will solve this issue. Think step by step.
